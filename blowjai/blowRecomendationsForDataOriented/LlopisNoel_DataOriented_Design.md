http://gamesfromwithin.com/data-oriented-design

Data-Oriented Design (Or Why You Might Be Shooting Yourself in The Foot With OOP) by Llopis, 2009 

"The culprit? Random memory access patterns and constant cache misses. "

### With regards to Procedural Programming and OOP:
"Notice that the main focus of both approaches is code: plain procedures (or functions) in one case, and grouped code associated with some internal state in the other. Data-oriented design shifts the perspective of programming from objects to the data itself: The type of the data, how it is laid out in memory, and how it will be read and processed in the game."
This can be thought of as <b>particle-driven programming</b> (Llopis, 2009). 

### Clearing up confusion
"A data-driven game is usually a game that exposes a large amount of functionality outside of code and lets the data determine the behavior of the game." This is orthogonal to data-oriented and so this is applicable to any type of programming approach (Llopis, 2009).

## Ideal data
What's the format?
The data is in a format that can be used with the least amount of effort; the format is identical with the output under ideal circumstances. 
Processing is therefore limited to copying that information. 

<b> Large blocks of contiguous, homogenous data that is processed sequentially </b> because this goes along with the general goal of minimizing transformations. This can be baked during asset-building. 

Consider
<img src='http://gamesfromwithin.com/wp-content/uploads/2009/12/oo_design.png'> 
versus
<img src='http://gamesfromwithin.com/wp-content/uploads/2009/12/do_design1.png'>

## This removes trees: inheritence, containment, or message-passing trees. 

# how
1. Break down each object into different components, 
2. Group the components of the same type together in memory regardless of what object they came from

# why-how
OOP relies on one object but in complex state machines there are rarely singular instances of objects.

#advantages 
## parallelization 
-> Consider the tedious task of parallelizing object-oriented code. It is error-prone due to sometimes confusing synchronization tasks (meant to halt concurrency at specific data; this causes idling until it has been debugged).
In data-oriented design, this is a much simpler process: data is input, a small function is assigned to process it and return output. That transformation can easily be taken and split among multiple threads with minimal synchronization to account for. (This can even be completed on the processor's local memory). 

## cache utilization
-> A codebase that is data-oriented is very efficient in its use of the instruction cache because the same code is executed repeatedly. 
-> If the data is layed out in large, contiguous blocks, the data can be processed sequentially which results in impeccable cache utility, which translates into performance. 
-> This is much simpler than re-writing C in assembly. 

"Remember that all a game does is transform some data (assets, inputs, state) into some other data (graphics commands, new game states). By keeping in mind that flow of data, we can make higher-level, more intelligent decisions based on how the data is transformed, and how it is used. That kind of optimization can be extremely difficult and time- consuming to implement with more traditional OOP methods."

## modularity
-> The tendency is to write small functions because they will usually be needed for transformation. 
-> Lots of leaf functions/subroutines without many dependencies; this makes the comprehension and alteration of the code very easy. 
## testing 
-> Testing is a simple process of calling transform functions and checking output data, as opposed to investigation into potentially dense structures in memory. 

#disadvantages 
1) different from what people use or what they're taught in school; the way the programmer has to conceptualize their craft has to change fundamentally 
2) it can be tough to interface with existing code bases since it's a relatively novel approach across most work environments 

#application 
1) work backwards
-navigation
-animations
-collisions

2) identify data inputs required by the system
3) identify data outputs required by the system
e.g.  in animation: 
input = skeletons, base poses, animation data, and current state 
output = new set of poses and updated state(data generated by animations)


4)classify input data on how it's used:
-read-only
-read-write
-write-only
this helps guide decisions about where to store it and when to process it depending on dependencies from other parts of the program







"
At this point, stop thinking of the data required for a single operation, and think in terms of applying it to dozens or hundreds of entries. We no longer have one skeleton, one base pose, and a current state, and instead we have a block of each of those types with many instances in each of the blocks.

Think very carefully how the data is used during the transformation process from input to output. You might realize that you need to scan a particular field in a structure to perform a pass on the data, and then you need to use the results to do another pass. In that case, it might make more sense to split that initial field into a separate block of memory that can be processed independently, allowing for better cache utilization and potential parallelization. Or maybe you need to vectorize some part of the code, which requires fetching data from different locations to put it in the same vector register. In that case, that data can be stored contiguously so vector operations can be applied directly, without any extra transformations.

Now you should have a very good understanding of your data. Writing the code to transform it is going to be much simpler. It’s like writing code by filling in the blanks. You’ll even be pleasantly surprised to realize that the code is much simpler and smaller than you thought in the first place, compared to what the equivalent OOP code would have been.

If you think back about most of the topics we’ve covered in this column over the last year, you’ll see that they were all leading toward this type of design. Now it’s the time to be careful about how the data is aligned (Dec 2008 and Jan 2009), to bake data directly into an input format that you can use efficiently (Oct and Nov 2008), or to use non- pointer references between data blocks so they can be easily relocated (Sept 2009).
Is There Room For OOP?

Does this mean that OOP is useless and you should never apply it in your programs? I’m not quite ready to say that. Thinking in terms of objects is not detrimental when there is only one of each object (a graphics device, a log manager, etc) although in that case you might as well write it with simpler C-style functions and file-level static data. Even in that situation, it’s still important that those objects are designed around transforming data.

Another situation where I still find myself using OOP is GUI systems. Maybe it’s because you’re working with a system that is already designed in an object-oriented way, or maybe it’s because performance and complexity are not crucial factors with GUI code. In any case, I much prefer GUI APIs that are light on inheritance and use containment as much as possible (Cocoa and CocoaTouch are good examples of this). It’s very possible that a data-oriented GUI system could be written for games that would be a pleasure to work with, but I haven’t seen one yet.

Finally, there’s nothing stopping you from still having a mental picture of objects if that’s the way you like to think about the game. It’s just that the enemy entity won’t be all in the same physical location in memory. Instead, it will be split up into smaller subcomponents, each one forming part of a larger data table of similar components.

Data-oriented design is a bit of a departure from traditional programming approaches, but by always thinking about the data and how it needs to be transformed, you’ll be able to reap huge benefits both in terms of performance and ease of development.
"